from flask import Flask
from threading import Thread
import discord
from discord.ext import commands
import os
import random
import string
import base64
import asyncio

# Flask app for keeping bot alive
app = Flask(__name__)

@app.route('/')
def home():
    return "Bot is running!"

def run_flask():
    app.run(host='0.0.0.0', port=8080)

# Khởi chạy Flask trong thread riêng
flask_thread = Thread(target=run_flask)
flask_thread.daemon = True
flask_thread.start()

# Discord Bot
intents = discord.Intents.default()
intents.message_content = True

bot = commands.Bot(command_prefix='!', intents=intents, help_command=None)

def generate_encryption_key():
    """Tạo key mã hóa ngẫu nhiên"""
    return ''.join(random.choices(string.ascii_letters + string.digits, k=16))  # Giảm độ dài key

def xor_encrypt(data, key):
    """Mã hóa dữ liệu bằng XOR"""
    encrypted = bytearray()
    key_bytes = key.encode('utf-8')
    for i, byte in enumerate(data):
        encrypted.append(byte ^ key_bytes[i % len(key_bytes)])
    return bytes(encrypted)

def create_protected_lua(original_code, key):
    """Tạo file Lua được bảo vệ với code gốc bên trong"""
    # Mã hóa code gốc
    encrypted_data = xor_encrypt(original_code.encode('utf-8'), key)
    encrypted_b64 = base64.b64encode(encrypted_data).decode('utf-8')
    
    # Tạo file Lua đơn giản và chắc chắn chạy được
    protected_code = f'''-- File được bảo vệ
-- Auto-generated by Discord Bot

local encrypted = "{encrypted_b64}"
local key = "{key}"

-- Hàm decode base64 đơn giản
local function b64_decode(data)
    local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    local result = ""
    
    data = string.gsub(data, '[^'..b64chars..'=]', '')
    
    for i = 1, #data, 4 do
        local chunk = data:sub(i, i+3)
        if #chunk < 4 then break end
        
        local a = (b64chars:find(chunk:sub(1,1)) - 1) or 0
        local b = (b64chars:find(chunk:sub(2,2)) - 1) or 0
        local c = (b64chars:find(chunk:sub(3,3)) - 1) or 0
        local d = (b64chars:find(chunk:sub(4,4)) - 1) or 0
        
        local combined = a * 262144 + b * 4096 + c * 64 + d
        
        local bytes = {{
            math.floor(combined / 65536) % 256,
            math.floor(combined / 256) % 256,
            combined % 256
        }}
        
        for j = 1, #chunk-1 do
            if bytes[j] then
                result = result .. string.char(bytes[j])
            end
        end
    end
    
    return result
end

-- Hàm giải mã XOR
local function xor_decrypt(data, key)
    local result = ""
    local key_len = #key
    
    for i = 1, #data do
        local data_byte = data:byte(i)
        local key_byte = key:byte((i - 1) % key_len + 1)
        local decrypted_byte = data_byte ~ key_byte
        result = result .. string.char(decrypted_byte)
    end
    
    return result
end

-- Main execution
local function main()
    -- Giải mã
    local decoded_data = b64_decode(encrypted)
    local original_code = xor_decrypt(decoded_data, key)
    
    -- Thực thi code gốc
    local func, err = load(original_code)
    if func then
        return func()
    else
        -- Nếu load thất bại, thử với mode text
        local success, result = pcall(function()
            local f = loadstring(original_code)
            if f then return f() end
        end)
        
        if not success then
            error("Failed to execute original code: " .. (err or "unknown error"))
        end
    end
end

-- Chạy chương trình
local success, err = pcall(main)
if not success then
    print("Execution error: " .. tostring(err))
end
'''
    return protected_code

def create_simple_protected_lua(original_code, key):
    """Phiên bản đơn giản hơn để đảm bảo chạy được"""
    # Mã hóa code gốc
    encrypted_data = xor_encrypt(original_code.encode('utf-8'), key)
    encrypted_b64 = base64.b64encode(encrypted_data).decode('utf-8')
    
    # Tạo file Lua cực kỳ đơn giản
    protected_code = f'''-- Protected Lua File
local e="{encrypted_b64}"
local k="{key}"

-- Simple Base64 decode
function bd(d)
    local m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    local r=""
    d=d:gsub("[^"..m.."=]","")
    for i=1,#d,4 do
        local c=d:sub(i,i+3)
        if #c<4 then break end
        local a=(m:find(c:sub(1,1))-1)or 0
        local b=(m:find(c:sub(2,2))-1)or 0
        local c=(m:find(c:sub(3,3))-1)or 0
        local d=(m:find(c:sub(4,4))-1)or 0
        local n=a*262144+b*4096+c*64+d
        local x={{math.floor(n/65536)%256,math.floor(n/256)%256,n%256}}
        for j=1,#c-1 do if x[j] then r=r..string.char(x[j]) end end
    end
    return r
end

-- Simple XOR decrypt
function xd(d,k)
    local r=""
    for i=1,#d do
        local db=d:byte(i)
        local kb=k:byte((i-1)%#k+1)
        r=r..string.char(db~kb)
    end
    return r
end

-- Execute
local dc=bd(e)
local oc=xd(dc,k)
local f,err=load(oc)
if f then f() else print("Error:",err) end
'''
    return protected_code

@bot.event
async def on_ready():
    print(f'{bot.user} đã kết nối thành công!')
    await bot.change_presence(activity=discord.Game(name="!mahoa để mã hóa code"))
    
    try:
        synced = await bot.tree.sync()
        print(f"Đã đồng bộ {len(synced)} slash command(s)")
    except Exception as e:
        print(f"Lỗi đồng bộ slash commands: {e}")

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        return
    await ctx.send(f"Có lỗi xảy ra: {str(error)}")

@bot.command(name='mahoa')
async def encrypt_code(ctx):
    """Lệnh mã hóa file code"""
    if not ctx.message.attachments:
        await ctx.send(" Vui lòng gửi file code đính kèm khi sử dụng lệnh `!mahoa`")
        return
    
    attachment = ctx.message.attachments[0]
    
    # Kiểm tra file type
    valid_extensions = ['.lua', '.txt', '.py', '.js', '.cpp', '.c', '.java', '.php', '.xml', '.json']
    if not any(attachment.filename.lower().endswith(ext) for ext in valid_extensions):
        await ctx.send(" File không hợp lệ. Chỉ chấp nhận file code")
        return
    
    try:
        wait_msg = await ctx.send(" Đang xử lý file...")
        
        # Tải file
        file_content = await attachment.read()
        original_code = file_content.decode('utf-8')
        
        # Tạo key mã hóa (ngắn hơn để tránh lỗi)
        encryption_key = generate_encryption_key()
        
        # Tạo file được bảo vệ - dùng phiên bản đơn giản
        protected_lua_code = create_simple_protected_lua(original_code, encryption_key)
        
        # Tạo tên file mới
        original_name = os.path.splitext(attachment.filename)[0]
        encrypted_filename = f"{original_name}_protected.lua"
        
        # Lưu file tạm
        with open(encrypted_filename, 'w', encoding='utf-8') as f:
            f.write(protected_lua_code)
        
        # Kiểm tra code trước khi gửi
        print(f"Đã tạo file: {encrypted_filename}")
        print(f"Key length: {len(encryption_key)}")
        print(f"Original code length: {len(original_code)}")
        print(f"Protected code length: {len(protected_lua_code)}")
        
        # Gửi file đã mã hóa
        with open(encrypted_filename, 'rb') as f:
            file = discord.File(f, filename=encrypted_filename)
            embed = discord.Embed(
                title=" Mã Hóa Thành Công",
                description=f"File `{attachment.filename}` đã được bảo vệ",
                color=0x00ff00
            )
            embed.add_field(
                name=" Thông tin",
                value="• File .lua đã sẵn sàng để chạy\n• Code gốc được bảo vệ bên trong\n• Tương thích với Lua 5.1+",
                inline=False
            )
            embed.add_field(
                name=" Gỡ lỗi",
                value="Nếu file không chạy, hãy kiểm tra:\n• Lua version (5.1+)\n• Code gốc có lỗi syntax không",
                inline=False
            )
            await ctx.send(embed=embed, file=file)
        
        # Xóa file tạm
        os.remove(encrypted_filename)
        await wait_msg.delete()
        
    except Exception as e:
        await ctx.send(f" Lỗi khi xử lý file: {str(e)}")
        import traceback
        traceback.print_exc()

@bot.command(name='test')
async def test_command(ctx):
    """Tạo file test đơn giản để kiểm tra"""
    test_code = '''print("Hello World!")
for i = 1, 5 do
    print("Count:", i)
end
print("Test completed!")'''
    
    try:
        encryption_key = generate_encryption_key()
        protected_lua_code = create_simple_protected_lua(test_code, encryption_key)
        
        with open("test_protected.lua", 'w', encoding='utf-8') as f:
            f.write(protected_lua_code)
        
        with open("test_protected.lua", 'rb') as f:
            file = discord.File(f, filename="test_example.lua")
            await ctx.send(" File test đơn giản:", file=file)
        
        os.remove("test_protected.lua")
        
    except Exception as e:
        await ctx.send(f" Lỗi test: {str(e)}")

@bot.command(name='ping')
async def ping(ctx):
    """Kiểm tra độ trễ"""
    latency = round(bot.latency * 1000)
    await ctx.send(f' Ping! Độ trễ: {latency}ms')

@bot.command(name='trogiup')
async def help_command(ctx):
    """Hướng dẫn sử dụng"""
    help_text = """
**🤖 Bot Bảo Vệ Code - FIXED**

**Lệnh:**
`!mahoa` - Bảo vệ file code (đã sửa lỗi)
`!test` - Tạo file test để kiểm tra
`!ping` - Kiểm tra độ trễ
`!trogiup` - Hiển thị hướng dẫn

**ĐÃ SỬA LỖI:**
• Base64 decode đơn giản hơn
• XOR decrypt tối ưu
• Tương thích Lua 5.1+
• Xử lý lỗi tốt hơn

**Hỗ trợ file:** .lua, .txt, .py, .js, .cpp, .c, .java, .php, .xml, .json
"""
    await ctx.send(help_text)

# Slash command support
@bot.tree.command(name="mahoa", description="Bảo vệ file code thành file .lua (đã sửa lỗi)")
async def slash_encrypt(interaction: discord.Interaction):
    """Slash command cho mã hóa"""
    await interaction.response.send_message("Vui lòng gửi file code đính kèm khi sử dụng lệnh này. Sử dụng `!mahoa` với file đính kèm.")

@bot.event
async def on_message(message):
    if message.content in ['/mahoa', '!mahoa'] and not message.attachments:
        await message.channel.send("❌ Vui lòng gửi file code đính kèm khi sử dụng lệnh này.")
    
    await bot.process_commands(message)

# Chạy bot với token từ environment variable
if __name__ == "__main__":
    token = os.environ.get('TOKEN')
    if not token:
        print("Lỗi: TOKEN không được tìm thấy trong environment variables!")
        exit(1)
    
    print("🤖 Đang khởi động bot...")
    print("🌐 Flask server đang chạy trên port 8080")
    bot.run(token)
